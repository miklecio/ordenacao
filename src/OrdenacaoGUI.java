
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Random;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author miklecio.costa
 */
public class OrdenacaoGUI extends javax.swing.JFrame {
    
    private int[] valoresIniciais;
    private long memoryBefore;

    /**
     * Creates new form OrdenacaoGUI
     */
    public OrdenacaoGUI() {
        initComponents();
        valoresIniciais = new int[1000];
        fillRandom(valoresIniciais);
        jLabelValoresIniciais.setText(arrayToString(valoresIniciais));
        Runtime rt = Runtime.getRuntime();
        memoryBefore = rt.totalMemory() - rt.freeMemory();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jComboBoxMetodo = new javax.swing.JComboBox<>();
        jLabel2 = new javax.swing.JLabel();
        jButtonOrdenar = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        jLabelValoresIniciais = new javax.swing.JLabel();
        jLabelValoresFinais = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabelTempo = new javax.swing.JLabel();
        jButtonGerar = new javax.swing.JButton();
        jButtonComparar = new javax.swing.JButton();
        jPanelGrafico = new javax.swing.JPanel();
        jSeparator1 = new javax.swing.JSeparator();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Outras Ordenações");

        jLabel1.setText("Valores não ordenados:");

        jComboBoxMetodo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Comb sort", "Shell sort", "Heapsort", "Radix sort", "Counting sort" }));

        jLabel2.setText("Método:");

        jButtonOrdenar.setText("Ordenar");
        jButtonOrdenar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonOrdenarActionPerformed(evt);
            }
        });

        jLabel3.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel3.setText("Valores ordenados:");

        jLabelValoresIniciais.setText(" ");

        jLabelValoresFinais.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelValoresFinais.setText(" ");

        jLabel4.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel4.setText("Tempo gasto:");

        jLabelTempo.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelTempo.setText(" ");

        jButtonGerar.setText("Gerar");
        jButtonGerar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonGerarActionPerformed(evt);
            }
        });

        jButtonComparar.setText("Comparar");
        jButtonComparar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonCompararActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanelGraficoLayout = new javax.swing.GroupLayout(jPanelGrafico);
        jPanelGrafico.setLayout(jPanelGraficoLayout);
        jPanelGraficoLayout.setHorizontalGroup(
            jPanelGraficoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        jPanelGraficoLayout.setVerticalGroup(
            jPanelGraficoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 319, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(20, 20, 20)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabelValoresFinais)
                            .addComponent(jLabelValoresIniciais)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addGap(18, 18, 18)
                                .addComponent(jButtonGerar))
                            .addComponent(jLabel3)
                            .addComponent(jLabel4)
                            .addComponent(jLabelTempo)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addGap(18, 18, 18)
                                .addComponent(jComboBoxMetodo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(76, 76, 76)
                                .addComponent(jButtonOrdenar)
                                .addGap(18, 18, 18)
                                .addComponent(jButtonComparar)))
                        .addGap(0, 234, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jPanelGrafico, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jSeparator1)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(13, 13, 13)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel1)
                    .addComponent(jButtonGerar))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabelValoresIniciais)
                .addGap(27, 27, 27)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jComboBoxMetodo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonOrdenar)
                    .addComponent(jButtonComparar))
                .addGap(18, 18, 18)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabelValoresFinais)
                .addGap(18, 18, 18)
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabelTempo)
                .addGap(18, 18, 18)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanelGrafico, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonOrdenarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonOrdenarActionPerformed
        jLabelValoresIniciais.setText(arrayToString(valoresIniciais));
        int[] novo = Arrays.copyOf(valoresIniciais, valoresIniciais.length);
        long tempo;
        tempo = System.nanoTime();
        runSort(novo, jComboBoxMetodo.getSelectedIndex());
        tempo = System.nanoTime() - tempo;
        jLabelValoresFinais.setText(arrayToString(novo));
        jLabelTempo.setText(String.valueOf(tempo) + " ns");
    }//GEN-LAST:event_jButtonOrdenarActionPerformed

    private void jButtonGerarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonGerarActionPerformed
        fillRandom(valoresIniciais);
        jLabelValoresIniciais.setText(arrayToString(valoresIniciais));
    }//GEN-LAST:event_jButtonGerarActionPerformed

    private void jButtonCompararActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonCompararActionPerformed
        long tempo, memoria;
        try {
            XYSeriesCollection dataset = new XYSeriesCollection();
            int seriesSize = 5;
            String[] legendas = {"Comb", "Shell", "Heap", "Radix", "Counting"};
            XYSeries[] series = new XYSeries[seriesSize];
            for (int i = 0; i < seriesSize; ++i) {
                series[i] = new XYSeries(legendas[i]);
            }
            /*XYSeries combSeries = new XYSeries("Comb");
            XYSeries shellSeries = new XYSeries("Shell");
            XYSeries heapSeries = new XYSeries("Heap");
            XYSeries radixSeries = new XYSeries("Radix");
            XYSeries countingSeries = new XYSeries("Counting");*/
            PrintWriter tempoWriter = new PrintWriter("tempo_tmp.csv", "utf-8");
            PrintWriter memoriaWriter = new PrintWriter("memoria_tmp.csv", "utf-8");
            tempoWriter.println(";Comb;Shell;Heap;Radix;Counting");
            memoriaWriter.println(";Comb;Shell;Heap;Radix;Counting");
            Runtime rt = Runtime.getRuntime();
            for (int i = 0; i < 180; ++i) {
                int size = (i + 1)*1000;
                int [] valores = new int[size];
                fillRandom(valores);
                tempoWriter.print(size + ";");
                memoriaWriter.print(size + ";");
                int[] novo;
                
                for (int j = 0; j < seriesSize; ++j) {
                    novo = Arrays.copyOf(valores, valores.length);
                    tempo = System.nanoTime();
                    runSort(novo, j);
                    tempo = System.nanoTime() - tempo;
                    if (j < seriesSize - 1)
                        tempoWriter.print(tempo + ";");
                    else
                        tempoWriter.println(tempo);
                    series[j].add(size, tempo);
                    memoria = rt.totalMemory() - rt.freeMemory();
                    if (j < seriesSize - 1)
                        memoriaWriter.print((memoria - memoryBefore) + ";");
                    else
                        memoriaWriter.println((memoria - memoryBefore));
                    memoryBefore = memoria;
                }

                /*novo = Arrays.copyOf(valores, valores.length);
                tempo = System.nanoTime();
                shellSort(novo);
                tempo = System.nanoTime() - tempo;
                tempoWriter.print(tempo + ";");
                shellSeries.add(size, tempo);
                memoria = rt.totalMemory() - rt.freeMemory();
                memoriaWriter.print((memoria - memoryBefore) + ";");
                memoryBefore = memoria;

                novo = Arrays.copyOf(valores, valores.length);
                tempo = System.nanoTime();
                heapSort(novo);
                tempo = System.nanoTime() - tempo;
                tempoWriter.print(tempo + ";");
                heapSeries.add(size, tempo);
                memoria = rt.totalMemory() - rt.freeMemory();
                memoriaWriter.print((memoria - memoryBefore) + ";");
                memoryBefore = memoria;

                novo = Arrays.copyOf(valores, valores.length);
                int k = (int)Math.log10(size);
                tempo = System.nanoTime();
                radixSort(novo, k);
                tempo = System.nanoTime() - tempo;
                tempoWriter.print(tempo + ";");
                radixSeries.add(size, tempo);
                memoria = rt.totalMemory() - rt.freeMemory();
                memoriaWriter.print((memoria - memoryBefore) + ";");
                memoryBefore = memoria;

                novo = Arrays.copyOf(valores, valores.length);
                tempo = System.nanoTime();
                countingSort(novo, size);
                tempo = System.nanoTime() - tempo;
                tempoWriter.println(tempo);
                countingSeries.add(size, tempo);
                memoria = rt.totalMemory() - rt.freeMemory();
                memoriaWriter.println((memoria - memoryBefore));
                memoryBefore = memoria;*/
            }
            tempoWriter.close();
            memoriaWriter.close();
            for (int i = 0; i < seriesSize; ++i) {
                dataset.addSeries(series[i]);
            }
            /*dataset.addSeries(combSeries);
            dataset.addSeries(shellSeries);
            dataset.addSeries(heapSeries);
            dataset.addSeries(radixSeries);
            dataset.addSeries(countingSeries);*/
            
            String titulo = "Comparativo das Ordenações";
            String eixoy = "Tempo (ns)";
            String eixox = "Tamanho";
            boolean legenda = true;
            boolean tooltips = true;
            boolean urls = true;
            JFreeChart graf = ChartFactory.createXYLineChart(titulo, eixox, eixoy, dataset, PlotOrientation.VERTICAL, legenda, tooltips, urls);
            ChartPanel myChartPanel = new ChartPanel(graf, true);
            myChartPanel.setSize(jPanelGrafico.getWidth(), jPanelGrafico.getHeight());
            myChartPanel.setVisible(true);
            jPanelGrafico.removeAll();
            jPanelGrafico.add(myChartPanel);
            jPanelGrafico.revalidate();
            jPanelGrafico.repaint();
        }
        catch(Exception e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_jButtonCompararActionPerformed

    
    private static void runSort(int[] array, int tipo) {
        switch (tipo) {
            /*case 0:
                gnomeSort(novo);
                break;*/
            case 0:
                combSort(array);
                break;
            case 1:
                shellSort(array);
                break;
            case 2:
                heapSort(array);
                break;
            case 3:
                int k = (int)Math.log10(array.length);
                radixSort(array, k);
                break;
            case 4:
                countingSort(array, array.length);
                break;
        }
    }
    
    private static String arrayToString(int[] array) {
        String string = "";
        if (array.length > 23) {
            int[] inicio = Arrays.copyOf(array, 11);
            int[] fim = Arrays.copyOfRange(array, array.length-11, array.length);
            string += arrayToString(inicio);
            string += ", ..., ";
            string += arrayToString(fim);
        }
        else {
            for (int i = 0; i < array.length; ++i) {
                string += array[i];
                if (i != array.length - 1) {
                    string += ", ";
                }
            }
        }
        return string;
    }
    
    private void fillRandom(int[] valores) {
        Random rand = new Random();
        for (int i = 0; i < valores.length; i++) {
            valores[i] = rand.nextInt(valores.length);
        }
    }
    
    private static void swap(int[] v, int j, int aposJ) {
        int aux = v[j];
        v[j] = v[aposJ];
        v[aposJ] = aux;
    }
    
    private static void gnomeSort(int[] valores) {
        int pivot = 0;
        while (pivot < (valores.length - 1)) {
            if (valores[pivot] > valores[pivot + 1]) {
                swap(valores, pivot, pivot + 1);
                if (pivot > 0) {
                    pivot -= 2;
                }
            }
            pivot++;
        }
    }
    
    private static void combSort(int[] valores) {
        int gap = valores.length;
        boolean swapped = true;
        
        while (gap > 1 || swapped) {
            if (gap > 1) {
                gap = (int) (gap / 1.247330950103979);
            }

            int i = 0;
            swapped = false;
            while (i + gap < valores.length) {
                if (valores[i] > valores[i + gap]) {
                    swap(valores, i, i + gap);
                    swapped = true;
                }
                i++;
            }
        }
    }
    
    private static void shellSort(int[] valores) {
        int h = 1;
        int n = valores.length;
        
        while (h < n) {
            h = h * 3 + 1;
        }
        h = h / 3;
        int c, j;
        while (h > 0) {
            for (int i = h; i < n; i++) {
                c = valores[i];
                j = i;
                while (j >= h && valores[j - h] > c) {
                    valores[j] = valores[j - h];
                    j = j - h;
                }
                valores[j] = c;
            }
            h = h / 2;
        }
    }
    
    private static void heapSort(int[] valores) {
        buildMaxHeap(valores);
        int n = valores.length;

        for (int i = valores.length - 1; i > 0; i--) {
            swap(valores, i, 0);
            maxHeapify(valores, 0, --n);
        }
    }

    private static void buildMaxHeap(int v[]) {
        for (int i = v.length / 2 - 1; i >= 0; i--) {
            maxHeapify(v, i, v.length);
        }
    }

    private static void maxHeapify(int[] v, int pos, int n) {
        int max = 2 * pos + 1, right = max + 1;
        if (max < n) {
            if (right < n && v[max] < v[right]) {
                max = right;
            }
            if (v[max] > v[pos]) {
                swap(v, max, pos);
                maxHeapify(v, max, n);
            }
        }
    }
    
    private static void radixSort(int[] valores, int k) {
        for (int digit = 0; digit < k; digit++) {
            int power = (int) Math.pow(10, digit + 1);

            int z[][] = new int[valores.length][10];
            int n[] = new int[10];

            for (int i = 0; i < valores.length; i++) {
                int num = valores[i];
                z[n[(num % power) / (power / 10)]][(num % power) / (power / 10)] = num;
                n[(num % power) / (power / 10)]++;

            }
            int c = 0;
            for (int i = 0; i < 10; i++) {

                for (int j = 0; j < valores.length; j++) {
                    if (j < n[i]) {
                        valores[c] = z[j][i];
                        c++;
                    } else {
                        break;
                    }
                }
            }

        }
    }
    
    private static void countingSort(int[] valores, int k) {
        int c[] = new int[k];
        int[] a = Arrays.copyOf(valores, valores.length);
        for (int i = 0; i < a.length; i++) {
            c[a[i]]++;
        }
        for (int i = 1; i < k; i++) {
            c[i] += c[i - 1];
        }
        for (int i = a.length - 1; i >= 0; i--) {
            valores[--c[a[i]]] = a[i];
        }
    }

    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(OrdenacaoGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(OrdenacaoGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(OrdenacaoGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(OrdenacaoGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new OrdenacaoGUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonComparar;
    private javax.swing.JButton jButtonGerar;
    private javax.swing.JButton jButtonOrdenar;
    private javax.swing.JComboBox<String> jComboBoxMetodo;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabelTempo;
    private javax.swing.JLabel jLabelValoresFinais;
    private javax.swing.JLabel jLabelValoresIniciais;
    private javax.swing.JPanel jPanelGrafico;
    private javax.swing.JSeparator jSeparator1;
    // End of variables declaration//GEN-END:variables
}
